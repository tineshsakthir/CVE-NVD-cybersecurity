/*

CVE stands for Common Vulnerabilities and Exposures. 
It is a dictionary of publicly known information security vulnerabilities and exposures. 
Each CVE entry contains a unique identifier, a description of the vulnerability, and references
to related security advisories and patches.

The National Vulnerability Database (NVD) is a repository of information security 
vulnerabilities maintained by the National Institute of Standards and Technology (NIST) in the United States. 
It provides comprehensive information on vulnerabilities, including CVE entries, 
vulnerability severity scores, technical details, and mitigation strategies.

In summary, CVE is a standardized identifier for vulnerabilities, 
while NVD is a database that aggregates and provides information about these vulnerabilities, 
making it a valuable resource for organizations and individuals concerned with cybersecurity.

*/

import axios from "axios";
import express from "express";
import mongoose from "mongoose";
import path from "path";
import { storeToDbRouter } from "./routes/storeToDbFromApi.js";
import { CveListModel } from "./model/ListCve.js";
import { BackgroundSynchronizationModel } from "./model/BackgroundSynchronization.js";
const app = express();

mongoose.connect(
      "mongodb+srv://tinesh:sakthi@cvedatabase.rk1hb9f.mongodb.net/CVE?retryWrites=true&w=majority&appName=cveDatabase"
);

app.use(express.static(path.join(import.meta.dirname, "./public")));

// app.use('/cveList', )

// app.use('/storeToDbFromAPi', storeToDbRouter) ;

async function initialSynchronizeDataFromAPI(startIndex) {
      try {
            // Fetch data from the NVD API
            console.log(`At the index : ${startIndex}`);

            const response = await axios.get(
                  `https://services.nvd.nist.gov/rest/json/cves/2.0/?resultsPerPage=500&startIndex=${startIndex}`
            );

            startIndex = startIndex + 100;
            const totalCve = response.data.vulnerabilities;
            console.log(startIndex)
            // Process and save data to the database
            for (const singleCve of totalCve) {
                  // console.log("hi")
                  const curId = singleCve.cve.id;
                  const sourceIdentifier = singleCve.cve.sourceIdentifier;
                  const published = singleCve.cve.published;
                  const lastModified = singleCve.cve.lastModified;
                  const vulnStatus = singleCve.cve.vulnStatus;

                  if (
                        !curId ||
                        !sourceIdentifier ||
                        !published ||
                        !lastModified ||
                        !vulnStatus
                  ) {
                        console.log(`Not enough Data present to do so ${curId}`)
                        continue;
                  }

                  // Check if CVE already exists in the database
                  const existingCve = await CveListModel.findOne({ cveId: curId });

                  if (!existingCve) {
                        // Create a new document in the database
                        console.log(`Created now , cveId : ${curId} `);
                        await CveListModel.create({
                              cveId: curId,
                              sourceIdentifier: sourceIdentifier,
                              published: published,
                              lastModified: lastModified,
                              vulnStatus: vulnStatus,
                        });

                  } else {
                        if (existingCve.lastModified !== lastModified) {
                              // Update existing CVE document
                              existingCve.sourceIdentifier = sourceIdentifier;
                              existingCve.published = published;
                              existingCve.lastModified = lastModified;
                              existingCve.vulnStatus = vulnStatus;
                              await existingCve.save();
                        } else {
                              console.log(`lastModified unchanged, no update needed for cveId : ${curId}`);
                        }
                  }
            }
            console.log("CVE data synchronized from API successfully");
      } catch (error) {
            console.error("Error synchronizing CVE data from API:", error);
      }
}


setTimeout(async () => {
      try {
            // const count = await CveListModel.countDocuments({});
            //Instead of using the above, i just used a separate collection to handle that
            const count = await BackgroundSynchronizationModel.countDocuments({});

            console.log(count);
            //I am doing this because to bear the server shut down at the first five starting , at the worst case this will help us to push all the data into the db, after that i will only update the db with the help of another api provide by the national vulnerability database
            if (count === 0) {
                  let limit = 2000
                  console.log("Calling initialSynchronizeDataFromAPI()...");
                  let startIndex = 0;
                  let flagTocheckWhetherMyAsyncFunctionIsRunning = false;
                  let intervalId = setInterval(async () => {
                        if (!flagTocheckWhetherMyAsyncFunctionIsRunning) {
                              flagTocheckWhetherMyAsyncFunctionIsRunning = true;
                              await initialSynchronizeDataFromAPI(startIndex);
                              startIndex = startIndex + 500;
                              if (startIndex >= limit) {
                                    clearInterval(intervalId);
                              }
                              flagTocheckWhetherMyAsyncFunctionIsRunning = false;
                        }

                  }, 1000)
                  if (startIndex >= limit) {
                        const today = new Date();
                        console.log(today);
                        const tomorrow = new Date(today.getTime() + (24 * 60 * 60 * 1000));
                        console.log("new date", tomorrow)
                        const newBackgroundSynchronization = new BackgroundSynchronizationModel({
                              synchronizedId: 7777, // THis also i need get from the env file
                              lastSynchronizedDateTime: today,
                              nextSynchronizationDateTime: tomorrow,
                        })
                        await newBackgroundSynchronization.save();
                  }
            } else {
                  //I need to take away this synchronizedId to the env file
                  const bckgroundSynchronization = await BackgroundSynchronizationModel.findOne({ synchronizedId: 7777 })
                  console.log("Data already exists in the database. Skipping synchronization.");
            }
      } catch (error) {
            console.error("Error occurred during countDocuments:", error);
      }
}, 5000); // This tiem out is needed to bear the start of the server, without using this time out  i can't call an async call back function,but this becomes non-blocking and the server will response to the other client requests

/*
During every start of the server, the db should not be updated,
so i need to store the last updated time in a db and next updation time in the db , to work effiiciently, so that i will update the db when that time comes,
it also tackles the stopping and starting of the server, so the updation will only occure at the current time........

Another point to note is, even when the server shutdowns just before the next updation time, the server will update the db after resttarting by seeing the nextUpdation time in the db


We can 
*/

// setTimeout(async () => {
//       setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000);
// }, 24 * 60 * 60 * 1000);

// Periodically update the database
// setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000); // Every 24 hours

app.get("/cve", async (req, res) => {
      const response = await axios.get(
            "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-1999-0334"
      );
      const data = await response.data;
      console.log("Non blocking proved from fetching cve");
      res.json(data);
});

app.get("/cveList", async (req, res) => {
      const response = await axios.get(
            "https://services.nvd.nist.gov/rest/json/cves/2.0"
      );
      const data = await response.data;
      console.log("Non blocking proved from fetching cve list");
      res.json(data);
})

const PORT = 40025;

app.listen(process.env.PORT || PORT, () => {
      console.log(`The server is listening in the port ${PORT} `);
});
