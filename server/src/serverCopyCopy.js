// CVE stands for Common Vulnerabilities and Exposures.
// It is a dictionary of publicly known information security vulnerabilities and exposures.
// Each CVE entry contains a unique identifier, a description of the vulnerability, and references
// to related security advisories and patches.

// The National Vulnerability Database(NVD) is a repository of information security
// vulnerabilities maintained by the National Institute of Standards and Technology(NIST) in the United States.
// It provides comprehensive information on vulnerabilities, including CVE entries,
//             vulnerability severity scores, technical details, and mitigation strategies.

// In summary, CVE is a standardized identifier for vulnerabilities,
// while NVD is a database that aggregates and provides information about these vulnerabilities,
//             making it a valuable resource for organizations and individuals concerned with cybersecurity.

import axios from "axios";
import express from "express";
import mongoose from "mongoose";
import path from "path";
import { BackgroundSynchronizationModel } from "./model/BackgroundSynchronization.js";
import { cveRouter } from "./routes/cve.js";
import { getBackgroundSynchronizationModel, 
    getBgSyncModelCount, 
    saveNewBackgroundSynchronizationModel, 
    saveNewCve, updateBackgroundSynchronizationModel, 
    updateExistingCve } from "./controllers/cveController.js";

const app = express();


//The below just allows all the request, that is from any origin.........
// app.use((req, res, next) => {
//       res.header('Access-Control-Allow-Origin', '*');
//       res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
//       next();
//     });


//Middlewares
//Cors configuration for allowing the React App to seek the endPoint with a request
import cors from "cors";
app.use(cors());

//Routes for cve Api
app.use("/", cveRouter);

// I first used atlas
//The below is the atlas link, but atlas is just providing 512 mb free storage
// mongoose.connect(
//       "mongodb+srv://tinesh:sakthi@cvedatabase.rk1hb9f.mongodb.net/CVE?retryWrites=true&w=majority&appName=cveDatabase"
// );

//Mongo connection for the local db

const MONGODB_URI = "mongodb://localhost:27017/cveDatabase";
mongoose.connect(MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});
const db = mongoose.connection;
db.on("connected", () => {
    console.log("\n<<<---Connected to MongoDB--->>>\n");
});
db.on("error", (err) => {
    console.error("Error connecting to MongoDB:", err);
});


//This is used in initialSynchronizeDataFromAPI() and periodicUpdateToSynchronizeDataFromAPI() to determine the update time Interval
const regularTimeInterval = 2 * 60 * 1000;


const initialSynchronizeDataFromAPI = async () => {
    try {
        console.log("\n<<<---At initialSynchronizeDataFromAPI()--->>>\n");
        //  I am mainly implementing this because, even if the server  got shut down at the middle of the initialization,
        // having the lastOfset in the hand will help us to continue from there

        const backgroundSynchronizationModel = await getBackgroundSynchronizationModel();
        let startIndex = 247189;
        if (backgroundSynchronizationModel) {
            startIndex = parseInt(backgroundSynchronizationModel.lastLeftIndex);
        }

        console.log(`At the offset : ${startIndex}`);

        // fetching the api and putting with the query parameter as startIndex
        const response = await axios.get(
            `https://services.nvd.nist.gov/rest/json/cves/2.0/?startIndex=${startIndex}`
        );


        const totalCve = response.data.vulnerabilities;

        // Process and save data to the database
        for (const singleCve of totalCve) {

            await saveNewCve(singleCve);

        }

        const now = new Date();
        const afterOneHour = new Date(now.getTime() + regularTimeInterval);

        console.log("Now : ", now);
        console.log("After One Hour", afterOneHour);

        console.log("startIndex : ", startIndex);
        console.log("resultsPerPage : ", response.data.resultsPerPage);


        const lastLeftIndexInTheCurrentRecursiveCall = parseInt(startIndex) + parseInt(response.data.resultsPerPage);
        console.log("lastLeftIndexInTheCurrentRecursiveCall : ", lastLeftIndexInTheCurrentRecursiveCall)


        if (backgroundSynchronizationModel) {
            await updateBackgroundSynchronizationModel(backgroundSynchronizationModel, lastLeftIndexInTheCurrentRecursiveCall);
        } else {
            await saveNewBackgroundSynchronizationModel(lastLeftIndexInTheCurrentRecursiveCall);
        }

        if (response.data.resultsPerPage === 2000) {
            await initialSynchronizeDataFromAPI();
        }

        if (response.data.resultsPerPage == 0) {
            console.log("No new Common Vulnerabilities and Exposures Added to the National Vulnerability Database!!!! Go back and come later!!!")
        }
        else {
            console.log("CVE data synchronized from API successfully");
        }
    } catch (error) {
        console.error("Error synchronizing CVE data from API:", error);
    }
};


const changeAPiDealer = async () => {
    try {

        console.log("\n<<<---At changeAPiDealer()--->>>\n");

        const backgroundSynchronization = await getBackgroundSynchronizationModel() ;

        //With out this toISOString(), the NVD Api is not accepting the api call
        const changeStartDate = new Date(backgroundSynchronization.lastSynchronizedDateTime).toISOString();
        const changeEndDate = new Date().toISOString();

        //Encode the DateTIme offset into %2B, because NVD Api is expecting it.......
        const encodedChangeStartDate = encodeURIComponent(changeStartDate);
        const encodedChangeEndDate = encodeURIComponent(changeEndDate);

        // API endpoint URL
        const apiUrl = `https://services.nvd.nist.gov/rest/json/cvehistory/2.0/?changeStartDate=${encodedChangeStartDate}&changeEndDate=${encodedChangeEndDate}`;

        console.log(apiUrl) ;

        const response = await axios.get(apiUrl);
        const data = response.data;

        if(data.resultsPerPage == 0){
            console.log("\nNot any updation done in this time Interval")
            return ;
        }

        // let delay=1000 ;
        let semophore = true
        let i=0 ; 
        const size = data.cveChanges.length ; 

        let intervalId = setInterval( async()=>{
            if(semophore){
                semophore = false 
                if(i>= size) {
                    clearInterval(intervalId) ;
                    return ;
                }
                await updateExistingCve(data.cveChanges[i].change.cveId);
                i++ ;
                semophore = true 
            }
        }, 10000)
        // for (const cveChange of data.cveChanges) {
        //     console.log("Changes made to cveId : ", cveChange.change.cveId);
            
        //     await updateExistingCve(cveChange.change.cveId, delay);
        //     delay = delay*10; 
        // }
        

    } catch (err) {
        console.log(err);
    }
}

//need to develop this ins the futre : done
const periodicUpdateToSynchronizeDataFromAPI = async () => {
    try {
        console.log("\n<<<---At periodicUpdateToSynchronizeDataFromAPI()--->>>\n");

        //Store the last added offset in the initial synchronization with the BackgroundSynchronizationModel to deal with the newly addded cves

        const backgroundSynchronization = await getBackgroundSynchronizationModel() ;
        const currentDateTime = new Date();
        const nextSynchronizationDateTime = new Date(
            backgroundSynchronization.nextSynchronizationDateTime
        );


        const timeDifference = nextSynchronizationDateTime - currentDateTime;
        const delayForSetTimeout = timeDifference >= 0 ? timeDifference : 0;

        console.log(`\nNext Synchronization in ${delayForSetTimeout} ms `);

        setTimeout(async () => {

            //Talk with the change api to deal with the changes made in the already available details
            // The change APi dealer should be called first, because the if we call the initialSynchronizeDataFromAPI() it will update the lastModified
            // SO changes made to the cve(in that time interval between last update) those who are already present locally will be  missed 
            await changeAPiDealer();


            //now i am just using initialSynchronizeDataFromAPI
            await initialSynchronizeDataFromAPI();

            console.log(`\nNext Synchronization in ${regularTimeInterval} ms`);

            setInterval(async () => {


                //Talk with the change api to deal with the changes made in the already available details
                // The change APi dealer should be called first, because the if we call the initialSynchronizeDataFromAPI() it will update the lastModified
                // SO changes made to the cve(in that time interval between last update) those who are already present locally will be  missed 

                await changeAPiDealer();


                //now i am just using initialSynchronizeDataFromAPI
                await initialSynchronizeDataFromAPI();

                console.log(`\nNext Synchronization in ${regularTimeInterval} ms`);

            }, regularTimeInterval);


        }, delayForSetTimeout);



    } catch (error) {
        console.error(
            "Error occurred while updating synchronization from the API",
            error
        );
    }
};

setTimeout(async () => {
    try {
        console.log("\n<<<---Synchronization Started At the Server--->>>\n");
        // const count = await CveListModel.countDocuments({});
        //Instead of using the above, i just used a separate collection to handle that
        const count = await getBgSyncModelCount() ;

        //I am doing this because to bear the server shut down at the first five starting , at the worst case this will help us to push all the data into the db, after that i will only update the db with the help of another api provide by the national vulnerability database
        if (count === 0) {
            console.log("Calling initialSynchronizeDataFromAPI()...");
            await initialSynchronizeDataFromAPI();
            await periodicUpdateToSynchronizeDataFromAPI();
        } else {

            console.log(
                "Data already exists in the database. So just calling periodicUpdateToSynchronizeDataFromAPI"
            );
            await periodicUpdateToSynchronizeDataFromAPI();
        }
    } catch (error) {
        console.error("Error occurred during countDocuments:", error);
    }
}, 5000); // This tiem out is needed to bear the start of the server, without using this time out  i can't call an async call back function,but this becomes non-blocking and the server will response to the other client requests

/*
        During every start of the server, the db should not be updated,
        so i need to store the last updated time in a db and next updation time in the db , to work effiiciently, so that i will update the db when that time comes,
        it also tackles the stopping and starting of the server, so the updation will only occure at the current time........
        
        Another point to note is, even when the server shutdowns just before the next updation time, the server will update the db after resttarting by seeing the nextUpdation time in the db
        
        
        We can 
        */

// setTimeout(async () => {
//       setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000);
// }, 24 * 60 * 60 * 1000);

// Periodically update the database
// setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000); // Every 24 hours

const PORT = 40030;

app.listen(process.env.PORT || PORT, () => {
    console.log(`The server is listening in the port ${PORT} `);
});
