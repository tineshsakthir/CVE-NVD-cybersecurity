/*

CVE stands for Common Vulnerabilities and Exposures. 
It is a dictionary of publicly known information security vulnerabilities and exposures. 
Each CVE entry contains a unique identifier, a description of the vulnerability, and references
to related security advisories and patches.

The National Vulnerability Database (NVD) is a repository of information security 
vulnerabilities maintained by the National Institute of Standards and Technology (NIST) in the United States. 
It provides comprehensive information on vulnerabilities, including CVE entries, 
vulnerability severity scores, technical details, and mitigation strategies.

In summary, CVE is a standardized identifier for vulnerabilities, 
while NVD is a database that aggregates and provides information about these vulnerabilities, 
making it a valuable resource for organizations and individuals concerned with cybersecurity.

*/

import axios from "axios";
import express from "express";
import mongoose from "mongoose";
import path from "path";
import { storeToDbRouter } from "./routes/storeToDbFromApi.js";
import { CveListModel } from "./model/ListCve.js";
import { BackgroundSynchronizationModel } from "./model/BackgroundSynchronization.js";
import { cveRouter } from "./routes/cve.js";

const app = express();

// Said by Yaswanth to disable the cors at the receive of the any request at the server
// Because my below cors middleware doesn't working

// update :(Regular Cors now fixed) Now its working, because i first used the cors middleware below the routes, so it doesn't apply to the cveRouter

//Cors configuration
import cors from "cors";
app.use(cors());

// app.use((req, res, next) => {
//       res.header('Access-Control-Allow-Origin', '*');
//       res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
//       next();
//     });

app.use("/", cveRouter);

// I first used atlas
//The below is the atlas link, but atlas is just providing 512 mb free storage
// mongoose.connect(
//       "mongodb+srv://tinesh:sakthi@cvedatabase.rk1hb9f.mongodb.net/CVE?retryWrites=true&w=majority&appName=cveDatabase"
// );

//Mongo connection for the local db

const MONGODB_URI = "mongodb://localhost:27017/cveDatabase";
mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
});
const db = mongoose.connection;
db.on("connected", () => {
      console.log("Connected to MongoDB");
});
db.on("error", (err) => {
      console.error("Error connecting to MongoDB:", err);
});

//I think the below is not needed. I am going to use react

app.use(express.static(path.join(import.meta.dirname, "./public")));

// app.use('/cveList', )

// app.use('/storeToDbFromAPi', storeToDbRouter) ;
let errorCve = "" ; 
const initialSynchronizeDataFromAPI = async (startIndex) => {
      try {
            console.log(`At the offset : ${startIndex}`);

            // fetching the api and putting with the query parameter as startIndex
            const response = await axios.get(
                  `https://services.nvd.nist.gov/rest/json/cves/2.0/?startIndex=${startIndex}`
            );
            const totalCve = response.data.vulnerabilities;

            if (!totalCve) {
                  return -1;
            }
            
            

            // Process and save data to the database
            for (const singleCve of totalCve) {
                  // console.log("hi")
                  
                  const curId = singleCve?.cve?.id || "Not Available";
                  if (curId === "Not Available") continue;
                  errorCve = curId ; 
                  const sourceIdentifier =
                        singleCve?.cve?.sourceIdentifier ?? "Not Available";
                  const published = singleCve?.cve?.published ?? "Not Available";
                  const lastModified = singleCve?.cve?.lastModified ?? "Not Available";
                  const vulnStatus = singleCve?.cve?.vulnStatus ?? "Not Available";

                  // ===cvssMetricV2 ===
                  let descriptions = singleCve?.cve?.descriptions ?? [{
                        lang: "Not Available",
                        value: "Not Available",
                        _id:"Not Available"
                  }];

                  //Done this line after getting error at the cveId : CVE-2006-7252
                  //Just to check whether the key is there but the value is empty, because mongoose won't allow that.......
                  descriptions = descriptions.filter((description) => description.lang !== "" && description.value !== "");

                  const baseSeverity =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.baseSeverity ??
                        "Not Available";
                  const baseScore =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore ??
                        "Not Available";
                  const vectorString =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData?.vectorString ??
                        "Not Available";
                  const accessVector =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData?.accessVector ??
                        "Not Available";
                  const accessComplexity =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData
                              ?.accessComplexity ?? "Not Available";
                  const authentication =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData?.authentication ??
                        "Not Available";
                  const confidentialityImpact =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData
                              ?.confidentialityImpact ?? "Not Available";
                  const integrityImpact =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData?.integrityImpact ??
                        "Not Available";
                  const availabilityImpact =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.cvssData
                              ?.availabilityImpact ?? "Not Available";

                  // ===Score===
                  const exploitabilityScore =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.exploitabilityScore ??
                        "Not Available";
                  const impactScore =
                        singleCve?.cve?.metrics?.cvssMetricV2?.[0]?.impactScore ??
                        "Not Available";

                  // ===CPE===

                  let cpeMatch = singleCve?.cve?.configurations?.[0]?.nodes?.[0]
                        ?.cpeMatch ?? [{
                        vulnerable: "Not Available",
                        criteria: "Not Available",
                        matchCriteriaId: "Not Available",
                  }];

                  //Done this line after getting error at the cveId : CVE-2006-7252
                  //Just to check whether the key is there but the value is empty, because mongoose won't allow that.......
                  cpeMatch = cpeMatch.filter((cpem)=> cpem.vulnerable!="" && cpem.criteria!="" && cpem.matchCriteriaId!="")

            
                  // Check if CVE already exists in the database to avoid dupication in out db
                  const existingCve = await CveListModel.findOne({ cveId: curId });

                  if (!existingCve) {
                        // Create a new document in the database
                        console.log(`Created now , cveId : ${curId} `);
                        await CveListModel.create({
                              cveId: curId,
                              sourceIdentifier: sourceIdentifier,
                              published: published,
                              lastModified: lastModified,
                              vulnStatus: vulnStatus,
                              descriptions: descriptions,
                              baseSeverity: baseSeverity,
                              baseScore: baseScore,
                              vectorString: vectorString,
                              accessVector: accessVector,
                              accessComplexity: accessComplexity,
                              authentication: authentication,
                              confidentialityImpact: confidentialityImpact,
                              integrityImpact: integrityImpact,
                              availabilityImpact: availabilityImpact,

                              exploitabilityScore: exploitabilityScore,
                              impactScore: impactScore,

                              cpeMatch: cpeMatch,
                        });
                  } else {
                        if (existingCve.lastModified !== lastModified) {
                              // Update existing CVE document
                              existingCve.sourceIdentifier = sourceIdentifier;
                              existingCve.published = published;
                              existingCve.lastModified = lastModified;
                              existingCve.descriptions = descriptions;
                              existingCve.vulnStatus = vulnStatus;
                              existingCve.baseSeverity = baseSeverity;
                              existingCve.baseScore = baseScore;
                              existingCve.vectorString = vectorString;
                              existingCve.accessComplexity = accessComplexity;
                              existingCve.accessVector = accessVector;
                              existingCve.authentication = authentication;
                              existingCve.confidentialityImpact = confidentialityImpact;
                              existingCve.integrityImpact = integrityImpact;
                              existingCve.availabilityImpact = availabilityImpact;
                              existingCve.exploitabilityScore = exploitabilityScore;
                              existingCve.impactScore = impactScore;
                              existingCve.cpeMatch = cpeMatch;
                              await existingCve.save();
                        } else {
                              console.log(
                                    `lastModified unchanged, no update needed for cveId : ${curId}`
                              );
                        }
                  }
            }
            console.log("CVE data synchronized from API successfully");
      } catch (error) {
            console.log(errorCve) ;
            console.error("Error synchronizing CVE data from API:", error);
      }
};

//need to develop this ins the futre
const updateToSynchronizeDataFromAPI = async () => {
      try {
            console.log("here at updateToSynchronizeDataFromAPI");
            //Store the last added offset in the initial synchronization with the BackgroundSynchronizationModel to deal with the newly addded cves


            //Talk with the change api to deal with the changes made in the already available details
      } catch (error) {
            console.error(
                  "Error occurred while updating synchronization from the API",
                  error
            );
      }
};

setTimeout(async () => {
      try {
            // const count = await CveListModel.countDocuments({});
            //Instead of using the above, i just used a separate collection to handle that
            const count = await BackgroundSynchronizationModel.countDocuments({});

            console.log(count);
            //I am doing this because to bear the server shut down at the first five starting , at the worst case this will help us to push all the data into the db, after that i will only update the db with the help of another api provide by the national vulnerability database
            if (count === 0) {
                  let limit = 20000;
                  console.log("Calling initialSynchronizeDataFromAPI()...");
                  let startIndex = 19000;
                  let flagTocheckWhetherMyAsyncFunctionIsRunning = false;
                  let intervalId = setInterval(async () => {
                        if (!flagTocheckWhetherMyAsyncFunctionIsRunning) {
                              flagTocheckWhetherMyAsyncFunctionIsRunning = true;
                              const res = await initialSynchronizeDataFromAPI(startIndex);
                              if (res == -1) return;
                              startIndex = startIndex + 2000;
                              if (startIndex >= limit) {
                                    clearInterval(intervalId);
                                    const today = new Date();
                                    console.log(today);
                                    const tomorrow = new Date(today.getTime() + 60 * 60 * 1000);
                                    console.log("new date", tomorrow);
                                    const newBackgroundSynchronization =
                                          new BackgroundSynchronizationModel({
                                                synchronizedId: 7777, // THis also i need get from the env file
                                                lastSynchronizedDateTime: today,
                                                nextSynchronizationDateTime: tomorrow,
                                          });
                                    await newBackgroundSynchronization.save();
                              }
                              flagTocheckWhetherMyAsyncFunctionIsRunning = false;
                        }
                  }, 1000);
            } else {
                  //I need to take away this synchronizedId to the env file
                  const backgroundSynchronization =
                        await BackgroundSynchronizationModel.findOne({ synchronizedId: 7777 });
                  const currentDateTIme = new Date();
                  const nextSynchronizationDateTime = new Date(
                        backgroundSynchronization.nextSynchronizationDateTime
                  );
                  if (nextSynchronizationDateTime <= currentDateTIme) {
                        await updateToSynchronizeDataFromAPI();
                  }
                  const regularTimeInterval = 60 * 60 * 1000;
                  const timeDifference = nextSynchronizationDateTime - currentDateTIme;
                  console.log(timeDifference);
                  const delayForSetTimeout = timeDifference >= 0 ? timeDifference : 0;
                  const delayForSetInterval =
                        timeDifference >= 0
                              ? timeDifference + regularTimeInterval
                              : regularTimeInterval;
                  console.log("delayForSetTimeout : ", delayForSetTimeout);
                  console.log("delayForSetInterval : ", delayForSetInterval);
                  setTimeout(async () => {
                        //now i am just using initialSynchronizeDataFromAPI, but need to shift to the "updateToSynchronizeDataFromAPI" with the different NVD APi
                        await updateToSynchronizeDataFromAPI();
                  }, delayForSetTimeout);

                  setInterval(async () => {
                        //now i am just using initialSynchronizeDataFromAPI, but need to shift to the "updateToSynchronizeDataFromAPI" with the different NVD APi
                        await updateToSynchronizeDataFromAPI();
                  }, delayForSetInterval);

                  console.log(backgroundSynchronization);
                  console.log(
                        "Data already exists in the database. So initial synchronization is Skipped."
                  );
            }
      } catch (error) {
            console.error("Error occurred during countDocuments:", error);
      }
}, 5000); // This tiem out is needed to bear the start of the server, without using this time out  i can't call an async call back function,but this becomes non-blocking and the server will response to the other client requests

/*
During every start of the server, the db should not be updated,
so i need to store the last updated time in a db and next updation time in the db , to work effiiciently, so that i will update the db when that time comes,
it also tackles the stopping and starting of the server, so the updation will only occure at the current time........

Another point to note is, even when the server shutdowns just before the next updation time, the server will update the db after resttarting by seeing the nextUpdation time in the db


We can 
*/

// setTimeout(async () => {
//       setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000);
// }, 24 * 60 * 60 * 1000);

// Periodically update the database
// setInterval(periodicallyUpdateDatabase, 24 * 60 * 60 * 1000); // Every 24 hours

const PORT = 40028;

app.listen(process.env.PORT || PORT, () => {
      console.log(`The server is listening in the port ${PORT} `);
});
