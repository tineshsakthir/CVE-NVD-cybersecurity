
import { CveListModel } from "../model/ListCve.js"
import axios from "axios";
import {
    getSourceIdentifier, getPublished,
    getLastModified, getDescriptions,
    getVulnStatus, getBaseSeverity,
    getBaseScore, getVectorString,
    getAccessVector, getAccessComplexity,
    getAuthentication, getConfidentialityImpact,
    getIntegrityImpact, getAvailabilityImpact,
    getExploitabilityScore, getImpactScore, getCpeMatch,
    getCveId
} from "../utils/cveJsonParsers.js";
import { BackgroundSynchronizationModel } from "../model/BackgroundSynchronization.js";
import { createLogger, errorLogger, updateLogger } from "../logEvents.js";


const getCveListFromMyDb = async (count, offset) => {
    try {
        const cveList = await CveListModel.find({})
        .sort({ published: 1, lastModified: -1 })
        .skip(offset).limit(count);
        return cveList;
    } catch (err) {
        errorLogger(`Error occured while fetching CVE list from the Db - ${err}`);
    }
}

const getSingleCveFromMyDb = async (cveId) => {
    try {
        const cve = await CveListModel.findOne({ cveId: cveId });
        return cve;
    } catch (err) {
        errorLogger(`Error occured while fetching a Single CVE from the Db - ${err}`);
    }
}


const getTotalCveCountInMyDb = async () => {
    try {
        const totCveCount = await CveListModel.countDocuments({});
        return totCveCount;
    } catch (err) {
        errorLogger(`Error occured while fetching the count of CVE in the Db - ${err}`);
    }
}

//Saves a new CVE to the Db with code cleansing and De-Duplication
const saveNewCve = async (singleCve) => {
    try {
        const cveId = getCveId(singleCve);
        const sourceIdentifier = getSourceIdentifier(singleCve);
        const published = getPublished(singleCve);
        const lastModified = getLastModified(singleCve);
        const vulnStatus = getVulnStatus(singleCve);

        // ===cvssMetricV2 ===
        let descriptions = getDescriptions(singleCve);

        const baseSeverity = getBaseSeverity(singleCve);
        const baseScore = getBaseScore(singleCve);
        const vectorString = getVectorString(singleCve);
        const accessComplexity = getAccessComplexity(singleCve);
        const accessVector = getAccessVector(singleCve);
        const authentication = getAuthentication(singleCve);
        const confidentialityImpact = getConfidentialityImpact(singleCve);
        const integrityImpact = getIntegrityImpact(singleCve);
        const availabilityImpact = getAvailabilityImpact(singleCve);

        // ===Score===
        const exploitabilityScore = getExploitabilityScore(singleCve);
        const impactScore = getImpactScore(singleCve);

        // ===CPE===

        let cpeMatch = getCpeMatch(singleCve);

        // Check if CVE already exists in the database to avoid dupication in out db
        const existingCve = await CveListModel.findOne({ cveId: cveId });

        if (!existingCve) {
            // Create a new document in the database
            createLogger(`Created now , cveId : ${cveId} `)
            await CveListModel.create({
                cveId: cveId,
                sourceIdentifier: sourceIdentifier,
                published: published,
                lastModified: lastModified,
                vulnStatus: vulnStatus,
                descriptions: descriptions,
                baseSeverity: baseSeverity,
                baseScore: baseScore,
                vectorString: vectorString,
                accessVector: accessVector,
                accessComplexity: accessComplexity,
                authentication: authentication,
                confidentialityImpact: confidentialityImpact,
                integrityImpact: integrityImpact,
                availabilityImpact: availabilityImpact,

                exploitabilityScore: exploitabilityScore,
                impactScore: impactScore,

                cpeMatch: cpeMatch,
            });
        } else {
            if (existingCve.lastModified !== lastModified) {
                // Update existing CVE document
                await updateExistingCve(existingCve.cveId);
            } else {
                createLogger(`lastModified unchanged, no update needed for cveId : ${cveId}`)
            }
        }
    } catch (err) {
        errorLogger(`Error occured while Creating a new CVE cveid : ${singleCve.cve.id}- ${err}`);

    }
}



const updateExistingCve = async (cveId) => {

    try {
        updateLogger(`Updating Existing CVE, cveId : ${cveId} `);

        const cveFromApi = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`);
        const singleCve = cveFromApi.data.vulnerabilities[0];
        const existingCve = await CveListModel.findOne({ cveId: cveId });

        if (existingCve.lastModified !== cveFromApi.lastModified) {
            existingCve.sourceIdentifier = getSourceIdentifier(singleCve);
            existingCve.published = getPublished(singleCve);
            existingCve.lastModified = getLastModified(singleCve);
            existingCve.vulnStatus = getVulnStatus(singleCve);
            existingCve.descriptions = getDescriptions(singleCve);
            existingCve.baseSeverity = getBaseSeverity(singleCve);
            existingCve.baseScore = getBaseScore(singleCve);
            existingCve.vectorString = getVectorString(singleCve);
            existingCve.accessComplexity = getAccessComplexity(singleCve);
            existingCve.accessVector = getAccessVector(singleCve);
            existingCve.authentication = getAuthentication(singleCve);
            existingCve.confidentialityImpact = getConfidentialityImpact(singleCve);
            existingCve.integrityImpact = getIntegrityImpact(singleCve);
            existingCve.availabilityImpact = getAvailabilityImpact(singleCve);
            existingCve.exploitabilityScore = getExploitabilityScore(singleCve);
            existingCve.impactScore = getImpactScore(singleCve);
            existingCve.cpeMatch = getCpeMatch(singleCve);
            await existingCve.save();
            updateLogger(`cveId : ${cveId} Updated`)
        } else {
            updateLogger(`lastModified unchanged, no update needed for cveId : ${cveId}`)
        }
    } catch (err) {
        errorLogger(`Error occured while Updating a Already Existed CVE - ${err}`);
    }

}


const getBackgroundSynchronizationModel = async () => {
    try {
        return await BackgroundSynchronizationModel.findOne({ synchronizedId: 7777 });
    } catch (err) {
        errorLogger(`Error occured while Fetching the BackgroundSynchronizationModel from the Db - ${err}`);
    }
}


const regularTimeInterval = 2 * 60 * 1000;

const saveNewBackgroundSynchronizationModel = async (lastLeftIndexInTheCurrentRecursiveCall) => {
    try{
        const now = new Date();
    const afterWards = new Date(now.getTime() + regularTimeInterval);
    const newBackgroundSynchronization = new BackgroundSynchronizationModel({
        synchronizedId: 7777, // THis also i need get from the env file
        lastSynchronizedDateTime: now,
        nextSynchronizationDateTime: afterWards,
        lastLeftIndex: lastLeftIndexInTheCurrentRecursiveCall,
        changeApilastSynchronized : now // Only during creating this field is given a value, but this field is updated only by the ChangeApi
    });
    await newBackgroundSynchronization.save();
    }catch(err){
        errorLogger(`Error occured while creating a BackgroundSynchronizationModel in the Db - ${err}`);

    }
}

const updateBackgroundSynchronizationModel = async (backgroundSynchronizationModel, lastLeftIndexInTheCurrentRecursiveCall) => {
    try{
        const now = new Date();
    const afterWards = new Date(now.getTime() + regularTimeInterval);
    backgroundSynchronizationModel.lastSynchronizedDateTime = now;
    backgroundSynchronizationModel.nextSynchronizationDateTime = afterWards;
    backgroundSynchronizationModel.lastLeftIndex = lastLeftIndexInTheCurrentRecursiveCall;
    await backgroundSynchronizationModel.save();
    }catch(err){
        errorLogger(`Error occured while updating a BackgroundSynchronizationModel in the Db - ${err}`);
    }
}


const updateBgSynchByChangeApi = async(backgroundSynchronizationModel) => {
    try{
        const now = new Date() ; 
        backgroundSynchronizationModel.changeApilastSynchronized = now ; 
        await backgroundSynchronizationModel.save() ; 
    }catch(err){
        errorLogger(`Error occured while updating( by Change Api ) a BackgroundSynchronizationModel in the Db - ${err}`);
    }
}

const getBgSyncModelCount = async () => {
    try{
        return await BackgroundSynchronizationModel.countDocuments({});
    }catch(err){
        errorLogger(`Error occured while getting the count of BackgroundSynchronizationModel in the Db - ${err}`);
    }

}


const getCveListByScore = async (score,offset,count) => {
    try{
        return await CveListModel.find({baseScore : score}).sort({ published: 1, lastModified: -1 }).skip(offset).limit(count) ; 
    }catch(err){
        errorLogger(`Error occured while fetching cves with score- ${err}`);
    }
}


const getCveListByYear = async (year,offset,count) => {
    try {

        const startDate = new Date(year, 0, 1); // Start of the year (January 1st)
        const endDate = new Date(parseInt(year) + 1, 0, 0); // End of the year (December 31st)
    
console.log(startDate) ;
console.log(endDate) ;
        const cveList = await CveListModel.find({
          published: { $gte: startDate, $lt: endDate }
        })
          .sort({ published: 1, lastModified: -1 })
          .skip(offset)
          .limit(count);

          console.log(cveList);
        return cveList;
      } catch (err) {
        console.error(`Error occurred while fetching CVEs for year ${year}: ${err}`);
        throw err;
      }
}






export {
    getCveListFromMyDb, getSingleCveFromMyDb,
    getTotalCveCountInMyDb, updateExistingCve, saveNewCve,
    getBackgroundSynchronizationModel, saveNewBackgroundSynchronizationModel,updateBgSynchByChangeApi ,
    updateBackgroundSynchronizationModel, getBgSyncModelCount , getCveListByScore, getCveListByYear
}