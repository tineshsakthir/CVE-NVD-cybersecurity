import mongoose from "mongoose"
import { CveListModel } from "../model/ListCve.js"
import axios from "axios";
import {
    getSourceIdentifier, getPublished,
    getLastModified, getDescriptions,
    getVulnStatus, getBaseSeverity,
    getBaseScore, getVectorString,
    getAccessVector, getAccessComplexity,
    getAuthentication, getConfidentialityImpact,
    getIntegrityImpact, getAvailabilityImpact,
    getExploitabilityScore, getImpactScore, getCpeMatch,
    getCveId
} from "../utils/cveJsonParsers.js";
import { BackgroundSynchronizationModel } from "../model/BackgroundSynchronization.js";


const getCveListFromMyDb = async (count, offset) => {
    try {
        const cveList = await CveListModel.find({}).sort({ published: 1, lastModified: -1 }).skip(offset).limit(count);
        return cveList;
    } catch (err) {
        console.log(err);
    }
}

const getSingleCveFromMyDb = async (cveId) => {
    try {
        const cve = await CveListModel.findOne({ cveId: cveId });
        return cve;
    } catch (err) {
        console.log(err);
    }
}


const getTotalCveCountInMyDb = async () => {
    try {
        const totCveCount = await CveListModel.countDocuments({});
        return totCveCount;
    } catch (err) {
        console.log(err);
    }
}

//Saves a new CVE to the Db with code cleansing and De-Duplication
const saveNewCve = async (singleCve) => {
    try {
        const cveId = getCveId(singleCve);
        const sourceIdentifier = getSourceIdentifier(singleCve);
        const published = getPublished(singleCve);
        const lastModified = getLastModified(singleCve);
        const vulnStatus = getVulnStatus(singleCve);

        // ===cvssMetricV2 ===
        let descriptions = getDescriptions(singleCve);

        const baseSeverity = getBaseSeverity(singleCve);
        const baseScore = getBaseScore(singleCve);
        const vectorString = getVectorString(singleCve);
        const accessComplexity = getAccessComplexity(singleCve);
        const accessVector = getAccessVector(singleCve);
        const authentication = getAuthentication(singleCve);
        const confidentialityImpact = getConfidentialityImpact(singleCve);
        const integrityImpact = getIntegrityImpact(singleCve);
        const availabilityImpact = getAvailabilityImpact(singleCve);

        // ===Score===
        const exploitabilityScore = getExploitabilityScore(singleCve);
        const impactScore = getImpactScore(singleCve);

        // ===CPE===

        let cpeMatch = getCpeMatch(singleCve);

        // Check if CVE already exists in the database to avoid dupication in out db
        const existingCve = await CveListModel.findOne({ cveId: cveId });

        if (!existingCve) {
            // Create a new document in the database
            console.log(`Created now , cveId : ${cveId} `);
            await CveListModel.create({
                cveId: cveId,
                sourceIdentifier: sourceIdentifier,
                published: published,
                lastModified: lastModified,
                vulnStatus: vulnStatus,
                descriptions: descriptions,
                baseSeverity: baseSeverity,
                baseScore: baseScore,
                vectorString: vectorString,
                accessVector: accessVector,
                accessComplexity: accessComplexity,
                authentication: authentication,
                confidentialityImpact: confidentialityImpact,
                integrityImpact: integrityImpact,
                availabilityImpact: availabilityImpact,

                exploitabilityScore: exploitabilityScore,
                impactScore: impactScore,

                cpeMatch: cpeMatch,
            });
        } else {
            if (existingCve.lastModified !== lastModified) {
                // Update existing CVE document
                await updateExistingCve(existingCve.cveId);
            } else {
                console.log(
                    `lastModified unchanged, no update needed for cveId : ${cveId}`
                );
            }
        }
    } catch (err) {

    }
}



const updateExistingCve = async (cveId) => {

try{
        console.log("At updateExistingCve for ",cveId);
        const cveFromApi = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`);
        const singleCve = cveFromApi.data.vulnerabilities[0];
        const existingCve = await CveListModel.findOne({ cveId: cveId });
    
        if (existingCve.lastModified !== cveFromApi.lastModified) {
            existingCve.sourceIdentifier = getSourceIdentifier(singleCve);
            existingCve.published = getPublished(singleCve);
            existingCve.lastModified = getLastModified(singleCve);
            existingCve.vulnStatus = getVulnStatus(singleCve);
            existingCve.descriptions = getDescriptions(singleCve);
            existingCve.baseSeverity = getBaseSeverity(singleCve);
            existingCve.baseScore = getBaseScore(singleCve);
            existingCve.vectorString = getVectorString(singleCve);
            existingCve.accessComplexity = getAccessComplexity(singleCve);
            existingCve.accessVector = getAccessVector(singleCve);
            existingCve.authentication = getAuthentication(singleCve);
            existingCve.confidentialityImpact = getConfidentialityImpact(singleCve);
            existingCve.integrityImpact = getIntegrityImpact(singleCve);
            existingCve.availabilityImpact = getAvailabilityImpact(singleCve);
            existingCve.exploitabilityScore = getExploitabilityScore(singleCve);
            existingCve.impactScore = getImpactScore(singleCve);
            existingCve.cpeMatch = getCpeMatch(singleCve);
            await existingCve.save();
            console.log(`${cveId} Updated`) ;
        } else {
            console.log(
                `lastModified unchanged, no update needed for cveId : ${cveId}`
            );
        }
}catch(err){
    console.log(err) ;
}

}


const getBackgroundSynchronizationModel = async () => {
        return await BackgroundSynchronizationModel.findOne({ synchronizedId: 7777 });

    }


    const regularTimeInterval = 2 * 60 * 1000;

    const saveNewBackgroundSynchronizationModel = async (lastLeftIndexInTheCurrentRecursiveCall) => {
        const now = new Date();
        const afterWards = new Date(now.getTime() + regularTimeInterval);
        const newBackgroundSynchronization = new BackgroundSynchronizationModel({
            synchronizedId: 7777, // THis also i need get from the env file
            lastSynchronizedDateTime: now,
            nextSynchronizationDateTime: afterWards,
            lastLeftIndex: lastLeftIndexInTheCurrentRecursiveCall
        });
        await newBackgroundSynchronization.save();
    }

    const updateBackgroundSynchronizationModel = async (backgroundSynchronizationModel, lastLeftIndexInTheCurrentRecursiveCall) => {
        const now =  new Date();
        const afterWards = new Date(now.getTime() + regularTimeInterval);
        backgroundSynchronizationModel.lastSynchronizedDateTime = now;
        backgroundSynchronizationModel.nextSynchronizationDateTime = afterWards;
        backgroundSynchronizationModel.lastLeftIndex = lastLeftIndexInTheCurrentRecursiveCall;
        await backgroundSynchronizationModel.save();
    }

    const getBgSyncModelCount = async () => {
        return await BackgroundSynchronizationModel.countDocuments({});
    }

    export {
        getCveListFromMyDb, getSingleCveFromMyDb,
        getTotalCveCountInMyDb, updateExistingCve, saveNewCve,
        getBackgroundSynchronizationModel, saveNewBackgroundSynchronizationModel,
        updateBackgroundSynchronizationModel, getBgSyncModelCount
    }